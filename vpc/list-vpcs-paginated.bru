meta {
  name: List VPCs (Paginated)
  type: http
  seq: 2
}

get {
  url: {{vpc_endpoint}}/v1/vpcs?version={{api_version}}&generation=2&limit={{PAGINATION_LIMIT}}&start={{START_TOKEN}}
  body: none
  auth: bearer
}

auth:bearer {
  token: {{bearer_token}}
}

headers {
  Accept: application/json
}

params:query {
  version: {{api_version}}
  generation: 2
  limit: {{PAGINATION_LIMIT}}
  start: {{START_TOKEN}}
}

script:post-response {
  if (res.status === 200) {
    const vpcs = res.body.vpcs;
    const totalCount = res.body.total_count;
    const limit = res.body.limit;
    const first = res.body.first;
    const next = res.body.next;

    console.log(`\n=== VPC List (Paginated) ===`);
    console.log(`\nPagination Info:`);
    console.log(`  Total VPCs: ${totalCount || 'N/A'}`);
    console.log(`  Limit: ${limit}`);
    console.log(`  Returned: ${vpcs.length}`);

    if (first && first.href) {
      console.log(`  First Page URL: ${first.href}`);
    }

    if (next && next.href) {
      console.log(`  Next Page URL: ${next.href}`);

      const nextUrl = next.href;
      const startMatch = nextUrl.match(/start=([^&]+)/);
      if (startMatch) {
        const nextToken = startMatch[1];
        console.log(`  Next Token: ${nextToken}`);
        console.log(`\nüí° To fetch next page, run:`);
        console.log(`  START_TOKEN="${nextToken}" mise run vpc:list-paginated`);
      }
    } else {
      console.log(`  Next Page: None (last page)`);
    }

    console.log(`\n--- VPCs on this page ---`);
    vpcs.forEach((vpc, index) => {
      console.log(`\n${index + 1}. ${vpc.name}`);
      console.log(`   ID: ${vpc.id}`);
      console.log(`   Status: ${vpc.status}`);
      console.log(`   Created: ${vpc.created_at}`);
      console.log(`   Resource Group: ${vpc.resource_group?.name || 'N/A'}`);
    });

    if (vpcs.length === 0) {
      console.log(`\n‚ö†Ô∏è  No VPCs found on this page`);
    }

    console.log(`\n--- Pagination Summary ---`);
    if (!next || !next.href) {
      console.log(`‚úÖ This is the last page`);
    } else {
      console.log(`‚û°Ô∏è  More pages available`);
    }

  } else if (res.status === 400) {
    console.error(`\n‚ùå Bad Request (400)`);
    console.error(`Error: ${res.body.errors?.[0]?.message || 'Invalid pagination token'}`);
    console.error(`\nPossible causes:`);
    console.error(`- START_TOKEN expired (tokens valid ~5 minutes)`);
    console.error(`- Invalid PAGINATION_LIMIT (must be 1-100)`);
    console.error(`\nSolution: Restart pagination from first page`);
  } else if (res.status === 401) {
    console.error("\n‚ùå Token expired - run 'mise run auth' again");
  }
}

docs {
  # List VPCs (Paginated)

  Demonstrates cursor-based pagination for listing VPCs.
  Use this endpoint when you have many VPCs and want to control page size.

  ## Pagination Parameters:

  **PAGINATION_LIMIT** (optional, default: 50):
  - Controls number of results per page
  - Valid range: 1 to 100
  - Smaller limits = more pages, less data per request
  - Larger limits = fewer pages, more data per request

  **START_TOKEN** (optional, default: none):
  - Cursor token from previous response.next.href
  - Points to first item of next page
  - Automatically generated by API
  - Typically expires after 5-10 minutes

  ## Usage Examples:

  ### First Page (no token, default limit of 50):
  ```bash
  mise run vpc:list-paginated
  ```

  ### First Page (custom limit of 10):
  ```bash
  PAGINATION_LIMIT=10 mise run vpc:list-paginated
  ```

  ### Next Page (using token from previous response):
  ```bash
  START_TOKEN="abc123xyz..." mise run vpc:list-paginated
  ```

  ### Next Page with custom limit:
  ```bash
  PAGINATION_LIMIT=20 START_TOKEN="abc123..." mise run vpc:list-paginated
  ```

  ## Pagination Workflow:

  1. **First Request (no START_TOKEN):**
     - Returns first page of results
     - Response includes:
       - vpcs: Array of VPC objects (up to limit)
       - total_count: Total VPCs across all pages
       - limit: Current page size
       - first: URL to first page
       - next: URL to next page (if more results exist)

  2. **Extract Next Token:**
     - From response.next.href, extract 'start' parameter
     - Example: https://...?start=abc123&version=...
     - Token: "abc123"

  3. **Subsequent Requests:**
     - Set START_TOKEN to extracted token
     - Keep same PAGINATION_LIMIT (recommended)
     - Repeat until response.next is null/missing

  4. **End of Results:**
     - When response.next is null or missing
     - You've fetched all pages

  ## Response Structure:

  ```json
  {
    "vpcs": [...],           // Array of VPC objects
    "total_count": 125,      // Total VPCs (all pages)
    "limit": 50,             // Current page size
    "first": {
      "href": "https://..."  // URL to first page
    },
    "next": {
      "href": "https://...?start=abc123..."  // URL to next page (or null)
    }
  }
  ```

  ## Best Practices:

  1. **Choose Appropriate Limit:**
     - Development/Testing: 10-20 (easier to verify pagination)
     - Production: 50 (default, good balance)
     - Large datasets: 100 (fewer API calls)

  2. **Handle Cursor Expiration:**
     - Cursors expire after 5-10 minutes
     - If you get 400 error, restart from first page
     - Don't save cursors for later use

  3. **Preserve Page Size:**
     - Use same PAGINATION_LIMIT across all pages
     - Changing limit mid-pagination may skip/duplicate results

  4. **Rate Limiting:**
     - Add delays between page requests if needed
     - IBM Cloud enforces API rate limits per key
     - Respect rate limits to avoid throttling

  5. **Process Incrementally:**
     - Don't load all pages into memory at once
     - Process each page, then fetch next
     - Stream results to file/database for large datasets

  6. **Error Handling:**
     - Check res.status on each request
     - Handle 400 (expired cursor) by restarting
     - Handle 401 (expired auth) by re-authenticating
     - Handle 429 (rate limit) with exponential backoff

  ## Common Scenarios:

  **Scenario 1: Small Result Set (< limit)**
  - Response: 10 VPCs, limit=50
  - Pages: 1 (no next link)
  - Pagination: Not needed

  **Scenario 2: Exact Boundary**
  - Response: 100 VPCs total, limit=50
  - Pages: 2 (next link on page 1, null on page 2)
  - Pagination: 2 requests needed

  **Scenario 3: Large Result Set**
  - Response: 1,000 VPCs total, limit=50
  - Pages: 20 (next link on pages 1-19, null on page 20)
  - Pagination: 20 requests needed

  **Scenario 4: Dynamic Result Set**
  - VPCs created/deleted during pagination
  - total_count may change between requests
  - Some items may appear twice or be skipped
  - Solution: Accept eventual consistency or restart pagination

  ## Pagination with Filters:

  Filters can be combined with pagination:

  ```bash
  # Filter by resource group + pagination
  RESOURCE_GROUP_ID="abc123..." PAGINATION_LIMIT=10 mise run vpc:list-paginated

  # Filter + next page
  RESOURCE_GROUP_ID="abc123..." START_TOKEN="xyz..." mise run vpc:list-paginated
  ```

  Filters apply to all pages consistently.

  ## Python Automation Example:

  See examples/pagination_example.py for complete Python script
  that automates pagination across all pages.

  ## Common Status Codes:

  - 200: Success
  - 400: Invalid pagination token (expired or malformed)
  - 401: Authentication failed (re-run auth)
  - 422: Invalid limit (must be 1-100)

  ## Performance Considerations:

  **API Call Cost:**
  - Each page = 1 API call
  - 1,000 VPCs with limit=50 = 20 API calls
  - Consider rate limits and quota

  **Network Transfer:**
  - Smaller limit = more requests, less data per request
  - Larger limit = fewer requests, more data per request
  - Balance based on network conditions

  **Processing Time:**
  - Cursor extraction: Negligible (< 1ms)
  - JSON parsing: O(n) where n = page size
  - Total time: Dominated by network latency

  ## API Reference:

  https://cloud.ibm.com/apidocs/vpc/latest#list-vpcs

  See "Pagination" section for detailed cursor-based pagination documentation.
}
